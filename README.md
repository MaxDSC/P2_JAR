# P2_JAR

#### *Цель работы*: освоить базовые команды git, получить навыки ввода/вывода в программе, научиться работать с базовыми конструкицями языка: ветвление и циклы, собирать и компилировать программы на java с помощью JAR-архива.

## *Содержание*

1. [Подготовка проекта](#1)\
   1.1. [Структура проекта](#11)\
   1.2  [Настройка IDE и стиль кода](#12)

2. [Задачи](#2)\
   2.1. [Quest 1](#21)\
   2.2. [Quest 2](#22)\
   2.3. [Quest 3](#23)\
   2.4. [Quest 4](#24)\
   2.5. [Quest 5](#25)

3. [Ход работы](#3).

## 1<a name="1"></a>. Подготовка проекта

### <a name="11"></a>1.1. Структура проекта
`mkdir P2_JAR`\
`cd P2_JAR`\
`mkdir target src`\
`cd src`\
`mkdir -p main/java main/resources test/java test/resources`\
`cd main/java`\
`mkdir -p maxdsc/quests`\
`cd ~/P2_JAR`\
`touch target/.gitkeep src/main/java/maxdsc/quests/.gitkeep src/main/resources/.gitkeep src/test/java/.gitkeep src/test/resources/.gitkeep`

- Название проекта P2_JAR
- *src* - исходный код программы
- *src/main/java* - исходный код, где хранятся пакеты в соответствии с квестом
- *src/main/resources* - файлы, используемые программой
- *src/test/java* - исходный код для тестирования программы
- *src/test/resources* - файлы, используемые для тестирования
- *target* - сборка исходного кода, здесь находятся файлы .class и JAR
- файл `README.md`
- файл `Makefile` - нужен для сборки проекта
- в каждой конечной папке есть файл *.gitkeep*, который нужен для считывания архитектруы проекта с помощью git

#### Дерево чистого проекта
```
P2_JAR
├── Makefile
├── README.md
├── src
│   ├── main
│   │   ├── java
│   │   │   └── maxdsc
│   │   │       └── quests
│   │   └── resources
│   └── test
│       ├── java
│       └── resources
└── target
```

## <a name="12"></a> 1.2. Настройка IDE и стиль кода
1. Для написания кода использовал [Eclipse IDE Enterprise Java and Web Developers](https://www.eclipse.org/downloads/packages/installer).
2. При написании кода придерживаюсь [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html).
    - Для форматирования кода по этому стилю загрузил в папку dropins eclipse-плагин [google-java-format-1.25](https://github.com/google/google-java-format), а также .xml файл с настройками стиля по этой [ссылке](https://github.com/google/styleguide/blob/gh-pages/eclipse-java-google-style.xml).
    - Для того, чтобы плагин заработал в Eclipse зайти в Window -> Preferences -> Java -> Code Style -> Formatter -> Formatter Implementation
    - Затем нужно выбрать .xml файл в Active Profile. Форматер будет работать при выделении кода `(CTRL + A) + CTRL+I`.
    - Также можно форматировать код прямо из консоли с помощью JAR файла google-java-format-1.25.2-all-deps.jar. Использовать команду `java -jar google-java-format-${GJF_VERSION?}-all-deps.jar -i [files...]`
    - Загрузил плагин [Checkstyle 10.21.3](https://checkstyle.org/) из Eclipse Marketplace. Данный плагин проверяет соответствует ли код стилю, и не дает запустить проект, если ошибки стиля неисправлены.
    - Загрузил JAR файл checkstyle-10.21.3-all, а также файл google_checks.xml согласно [инструкции](https://checkstyle.org/) для проверки стиля из консоли. Запуск проверки осуществляется командой `java -jar checkstyle-10.21.3-all.jar -c /google_checks.xml MyClass.java`


## <a name="2"></a> 2. Задачи

### <a name="21"></a> Quest 1

> Следующие задачи нужно решить не используя массивы и коллекции.

***Создать класс Divider.java, методы которого находят наибольший простой делитель вводимого с клавиатуры целого числа. Выполнить задачу без использования операции деления и взятия остатка от деления. Предусмотреть граничные случаи. В случае любой ошибки выводить "error".***

| System.in | System.out |
| ------| ------ |
| 200 | 5 |
| -8 | 2 |

### <a name="22"></a> Quest 2

***Создать класс Decode.java, который принимает через System.in режим работы (0 — кодирование,  1 — декодирование). Если выбран режим декодирования, то программа должна принимать из System.in разделенные пробелом двухсимвольные строки и выдавать в System.out декодированные символы, разделенные также пробелом. При кодировании выполняется обратная операция. Подзадачи кодирования и декодирования должны быть выделены в отдельные методы. Обратить внимание на ASCII таблицу. В случае любой ошибки выводить "error".***

| System.in (режим) | System.in | System.out |
| ------ | ------ | ------ |
| 0 | E N I G M A | 45 4E 49 47 4D 41 |
| 1 | 53 45 43 52 45 54 | S E C R E T |

### <a name="23"></a> Quest 3

***Создать класс Fibonacci.java, который рассчитывает и выводит на экран n-ое число Фибоначчи при помощи рекурсивного алгоритма. n-oe число вводится через System.in. В случае любой ошибки выводить "error".***

| System.in | System.out |
| ------ | ------ |
| 12 | 144 |
| 19 | 4181|

### <a name="24"></a>Quest 4

***Создать класс Functions.java, который рассчитывает и выводит на экран таблицу из трех функций: Верзьера Аньези с единичным диаметром, Лемниската Бернулли с единичным интервалом в положительной полуплоскости (Y > 0) и квадратичную гиперболу. В первом столбце перечисляются значения абсциссы от минус Пи до плюс Пи включительно, должно быть 42 замера на этом интервале. Второй, третьй и четвертый столбцы описывают значения функций в точке. Заголовки таблицы не нужны. Все значения записываются с точностью до 7 знаков после запятой, необходимо использовать тип double для повышенной точности. Разделитель между столбцами — " | ". Всего должно быть ровно 42 записи в таблице. Результат работы программы нужно разместить в файле src/main/resources/data.txt (запись в файл из программы реализовывать не нужно, можно использовать перенаправление вывода). В случае, если функция не определена в какой-либо точке, в таблице должен быть знак "-".***

## <a name="25"></a>Quest 5

***Дополнить класс Functions.java методом отрисовки так, чтобы он отрисовывал в терминале графики рассчитываемых функций при помощи символа "*". Масштаб по оси абсцисс — 42 отсечки, масштаб оси ординат — 21. Расположение и поворот координатых осей не принципиальны. ==***

## <a name="3"></a> 3. Ход работы

- Склонировал чистый проект P2_JAR командой `git clone`
- Перед началом работы создал ветку develop командой `git branch develop`, затем переключился на нее командой `git checkout develop`, проверил нахожусь ли я там командой `git branch -a`
- Каждый квест будет располагаться в разных package, в каждом package есть `package-info.java`, в котором описана задача, которую этот пакет выполняет. Внутри пакета maxdsc.quest расположил класс Main.java, в котором выполняются все квесты - таким образом, чтобы метод main использовал нужные классы и решал нужную задачу в зависимости от переданного аргумента `String[] args`, где число 1 - это первый квест, число 2 - второй квест и так далее.
- Файлы .java создавал командой `touch` внутри пакетов при помощи следующих команд:
```
touch src/main/java/maxdsc/quests/Main.java
mkdir src/main/java/maxdsc/quests/divider
touch src/main/java/maxdsc/quests/divider/Divider.java
touch src/main/java/maxdsc/quests/divider/package-info.java
```
- Для создания JAR-архивов придерживался [официальной документации.](https://docs.oracle.com/javase/tutorial/deployment/jar/build.html)

Для создания jar нужно ввести команду `jar cf jar-file input-file(s)`, где с - это указание, что мы создаем jar-архив, f - это указание вывода в файл

Для запуска необходимо указать главный класс - точку входа в программу, согласно [руководству](https://docs.oracle.com/javase/tutorial/deployment/jar/appman.html). Для этого надо создать файл манифеста в котором будет строка `Main-Class: MyPackage.MyClass`. Но можно создать архив и без файла манифеста с помощью флага `e`, например командой, `jar cfe target/P2_JAR Main target/Main.class`

При создании jar-архива нужно быть внимательным к указанию путей до главного класса. Например, если для создания архива была использована команда `jar cfm target/P2_JAR.jar Manifest.txt ~/my_java_projects/P2_JAR/target`, которая рекурсивно добавляет все папки и файлы `.class` из папки `target`, то для запуска программы файл `Manifest.txt` должен выглядеть так:
```
Manifest-Version: 1.0
Main-Class: maxdsc.quests.Main
class-path: home/maxik/my_java_projects/P2_JAR/target/
```
Данная команда сохраняет абсолютный путь до всех папок и файлов, что видно если запустить команду `jar tf P2_JAR`, вот её вывод:
```
META-INF/
META-INF/MANIFEST.MF
home/maxik/my_java_projects/P2_JAR/target/
home/maxik/my_java_projects/P2_JAR/target/maxdsc/
home/maxik/my_java_projects/P2_JAR/target/maxdsc/quests/
home/maxik/my_java_projects/P2_JAR/target/maxdsc/quests/Main.class
```
Если упустить фрагмент `class-path`, то команда `java -jar target/P2_JAR` не найдет главный класс, так как путь будет не полный.
Этого можно избежать используя относительные пути, что рекомендуется использовать в большинстве случаев. Для этого нужно использовать команду `jar cfm target/P2_JAR.jar Manifest.txt -С ~/my_java_projects/P2_JAR/target .`
где точка (.) означает обрезать путь начиная с target, то есть структура архива будет выглядеть так (jar tf P2_JAR):
```
META-INF/
META-INF/MANIFEST.MF
maxdsc/
maxdsc/quests/
maxdsc/quests/Main.class
```
Таким образом, мы можем взаимодействовать с классами внутри архива как с пакетами внутри проекта, что удобнее, а файл манифеста избавится от строчки class-path и будет выглядеть так:
```
Manifest-Version: 1.0
Main-Class: maxdsc.quests.Main
```
Чтобы запустить программу использую команду `java -jar target/P2_JAR.jar`

- Добавил команды, описанные выше, в *Makefile* для компиляции классов `.class` и сборки в JAR
- Для создания новых пакетов и классов пользовался командами консоли `mkdir, touch`. Если при создании папок и файлов eclipse не видит пакеты (создает default package), то нужно изменить файл `.classpath`, создаваемый при открытии в eclipse существующего проекта из файловой системы, таким образом:
```
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
	<classpathentry kind="src" path="src/main/java"/>
	<classpathentry kind="output" path="bin"/>
</classpath>
```
Обязательно посмотреть и изменить строки с `src` и `output`.
`src` - это место из которого все создаваемые папки далее будут пакетами для eclipse
`output` - это место куда компилируются все файлы из `src`.

1. Создал класс `Divider.java`, который будет решать первый квест.
- Алгоритм решения задачи.\
Наибольший простой делитель это делитель, который делится сам на себя и на единицу. Для того чтобы решить данную задачу без деления нужно последовательно складывать числа, например, возьмем число 50. Мы будем складывать последователь числа от 1 до 25, больше 25 не имеет смысла складывать так как уже понятно, что там делителя нет. Складывать единицы тоже смысла нет. Начинаем складывать с двойки: 2+2+2+2+...+2=50, сложить получилось, значит двойка это делитель, запоминаем её. Далее 3+3+3+..+3=50, не равно, значит тройка не делитель - пропускаем. Четверка тоже не подходит. 5+5+5+...+5=50, переписываем делитель на 5. Далее делитель перепишется на 10, потом на 25. Таким образом, наибольший делитель это 25 (выполняет метод `private int findLargestDivisor(int num)` в классе `Divider.java`). Далее нужно этот наибольший делитель пропустить через тот же алгорит, так как у 50 и 25 общий наибольший делитель (выполняет метод `private int checkDivisor()` в классе `Divider.java`). Таким образом, алгоритм доходит до числа 5, которое по этому алгоритму дальше не раскладывается (получается ноль), значит, это и есть наибольший простой делитель.
- Для компиляции добавил в *Makefile* к `javac` параметр `-sourcepath src/main/java`, который указывает где брать файлы исходного кода для компиляции связанных между собой классов, так как в классе `Main.java` идет обращение к другим классам.
- Упростил *Makefile*, так чтобы везде использовался относительный путь.
- Переместил библиотеки для проверки стиля [(см. п. 1.2)](#12) и форматирования кода по стилю в папку *lib*, в *Makefile* также изменил их вызов именно из этой папки

2. Для выволнения второго квеста создал пакет`maxdsc.quests.encrypt` и класс `Decode.java`.
- При выполнении второго квеста нужно быть внимательным в случае, если сначала использовать, для проверки режима кодирования/декодирования, `.nextInt`, а потом `.nextLine`, то не получится считать последнюю строку, так как после `.nextInt` остается кэш с символом переноса, то есть консоль не будет просить ввести строку в консоль.
- Для кодирования символов в методе `public void encode()`  использовал форматированный вывод `System.out.printf("%x ", decSymbol);` где `%x` указывает, что нужно переделать на выводе число из десятичной системы в шестнадцатиричную.
- Для декодирования строки, состоящей из подстрок двух символов в шестнадцатиричной системе, разделенных пробелами, в методе `public void decode()` использовал `String twoSymbols = new StringBuilder().append(symbol1).append(symbol2).toString();`, которая преобразует два символа, которые мы извлекаем из исходной строки в подстроку, обозначающую число в 16-ой системе, а затем переводим эту подстроку в число в десятичной системе с помощью  `Integer decSymbol = Integer.parseInt(twoSymbols, 16);`, и для вывода уже одного символа в нормальном виде используем форматированный вывод: `System.out.printf("%c ", decSymbol.intValue());`, где `%c` обозначает, что нужно преобразовать число в символ.

3. Для выполнения третьего квеста создал пакет`maxdsc.quests.fibonacci` и класс `Fibonacci.java`.
- Рекурсивно вычисление происходит с помощью следующей строчки кода в методе `private int calcFib(int n)`:
```
result = calcFib(n - 1) + calcFib(n - 2);
```
