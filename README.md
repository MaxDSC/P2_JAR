# P2_JAR

#### *Цель работы*: освоить базовые команды git, получить навыки ввода/вывода в программе, научиться работать с базовыми конструкицями языка: ветвление и циклы, собирать и компилировать программы на java с помощью JAR-архива.

## *Содержание*

1. [Подготовка проекта](#1)\
   1.1. [Структура проекта](#11)\
   1.2  [Настройка IDE и стиль кода](#12)

2. [Задачи](#2)\
   2.1. [Quest 1](#21)\
   2.2. [Quest 2](#22)\
   2.3. [Quest 3](#23)\
   2.4. [Quest 4](#24)\
   2.5. [Quest 5](#25)

3. [Ход работы](#3).

## 1<a name="1"></a>. Подготовка проекта

### <a name="11"></a>1.1. Структура проекта
`mkdir P2_JAR`\
`cd P2_JAR`\
`mkdir target src`\
`cd src`\
`mkdir -p main/java main/resources test/java test/resources`\
`cd main/java`\
`mkdir -p maxdsc/quests`\
`cd ~/P2_JAR`\
`touch target/.gitkeep src/main/java/maxdsc/quests/.gitkeep src/main/resources/.gitkeep src/test/java/.gitkeep src/test/resources/.gitkeep`

- Название проекта P2_JAR
- *src* - исходный код программы
- *src/main/java* - исходный код, где хранятся пакеты в соответствии с квестом
- *src/main/resources* - файлы, используемые программой
- *src/test/java* - исходный код для тестирования программы
- *src/test/resources* - файлы, используемые для тестирования
- *target* - сборка исходного кода, здесь находятся файлы .class и JAR
- файл `README.md`
- файл `Makefile` - нужен для сборки проекта
- в каждой конечной папке есть файл *.gitkeep*, который нужен для считывания архитектруы проекта с помощью git

#### Дерево чистого проекта
```
P2_JAR
├── Makefile
├── README.md
├── src
│   ├── main
│   │   ├── java
│   │   │   └── maxdsc
│   │   │       └── quests
│   │   └── resources
│   └── test
│       ├── java
│       └── resources
└── target
```

## <a name="12"></a> 1.2. Настройка IDE и стиль кода
1. Для написания кода использовал [Eclipse IDE Enterprise Java and Web Developers](https://www.eclipse.org/downloads/packages/installer).
2. При написании кода придерживаюсь [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html).
    - Для форматирования кода по этому стилю загрузил в папку dropins eclipse-плагин [google-java-format-1.25](https://github.com/google/google-java-format), а также .xml файл с настройками стиля по этой [ссылке](https://github.com/google/styleguide/blob/gh-pages/eclipse-java-google-style.xml).
    - Для того, чтобы плагин заработал в Eclipse зайти в Window -> Preferences -> Java -> Code Style -> Formatter -> Formatter Implementation
    - Затем нужно выбрать .xml файл в Active Profile. Форматер будет работать при выделении кода `(CTRL + A) + CTRL+I`.
    - Также можно форматировать код прямо из консоли с помощью JAR файла google-java-format-1.25.2-all-deps.jar. Использовать команду `java -jar google-java-format-${GJF_VERSION?}-all-deps.jar -i [files...]`
    - Загрузил плагин [Checkstyle 10.21.3](https://checkstyle.org/) из Eclipse Marketplace. Данный плагин проверяет соответствует ли код стилю, и не дает запустить проект, если ошибки стиля неисправлены.
    - Загрузил JAR файл checkstyle-10.21.3-all, а также файл google_checks.xml согласно [инструкции](https://checkstyle.org/) для проверки стиля из консоли. Запуск проверки осуществляется командой `java -jar checkstyle-10.21.3-all.jar -c /google_checks.xml MyClass.java`


## <a name="2"></a> 2. Задачи

### <a name="21"></a> Quest 1

***Создать класс Divider.java, методы которого находят наибольший простой делитель вводимого с клавиатуры целого числа. Выполнить задачу без использования операции деления и взятия остатка от деления. Предусмотреть граничные случаи. В случае любой ошибки выводить "error".***

| System.in | System.out |
| ------| ------ |
| 200 | 5 |
| -8 | 2 |

### <a name="22"></a> Quest 2

***Создать класс Decode.java, который принимает через System.in режим работы (0 — кодирование,  1 — декодирование). Если выбран режим декодирования, то программа должна принимать из System.in разделенные пробелом двухсимвольные строки и выдавать в System.out декодированные символы, разделенные также пробелом. При кодировании выполняется обратная операция. Подзадачи кодирования и декодирования должны быть выделены в отдельные методы. Обратить внимание на ASCII таблицу. В случае любой ошибки выводить "error".***

| System.in (режим) | System.in | System.out |
| ------ | ------ | ------ |
| 0 | E N I G M A | 45 4E 49 47 4D 41 |
| 1 | 53 45 43 52 45 54 | S E C R E T |

### <a name="23"></a> Quest 3

***Создать класс Fibonacci.java, который рассчитывает и выводит на экран n-ое число Фибоначчи при помощи рекурсивного алгоритма. n-oe число вводится через System.in. В случае любой ошибки выводить "error".***

| System.in | System.out |
| ------ | ------ |
| 12 | 144 |
| 19 | 4181|

### <a name="24"></a>Quest 4

***Создать класс Functions.java, который рассчитывает и выводит на экран таблицу из трех функций: Верзьера Аньези с единичным диаметром, Лемниската Бернулли с единичным интервалом в положительной полуплоскости (Y > 0) и квадратичную гиперболу. В первом столбце перечисляются значения абсциссы от минус Пи до плюс Пи включительно, должно быть 42 замера на этом интервале. Второй, третьй и четвертый столбцы описывают значения функций в точке. Заголовки таблицы не нужны. Все значения записываются с точностью до 7 знаков после запятой, необходимо использовать тип double для повышенной точности. Разделитель между столбцами — " | ". Всего должно быть ровно 42 записи в таблице. Результат работы программы нужно разместить в файле src/main/resources/data.txt (запись в файл из программы реализовывать не нужно, можно использовать перенаправление вывода). В случае, если функция не определена в какой-либо точке, в таблице должен быть знак "-".***

## <a name="25"></a>Quest 5

***Дополнить класс Functions.java методом отрисовки так, чтобы он отрисовывал в терминале графики рассчитываемых функций при помощи символа "*". Масштаб по оси абсцисс — 42 отсечки, масштаб оси ординат — 21. Расположение и поворот координатых осей не принципиальны. ==***

## <a name="3"></a> 3. Ход работы
